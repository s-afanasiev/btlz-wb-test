# Шаблон для выполнения тестового задания

## Описание
Шаблон подготовлен для того, чтобы попробовать сократить трудоемкость выполнения тестового задания.
В шаблоне настоены контейнеры для `postgres` и приложения на `nodejs`.  
Для взаимодействия с БД используется `knex.js`.  
В контейнере `app` используется `build` для приложения на `ts`, но можно использовать и `js`.

Все настройки можно найти в файлах:
- compose.yaml
- dockerfile
- package.json
- tsconfig.json
- src/config/env/env.ts
- src/config/knex/knexfile.ts

## Команды:
Для выполнения миграций и сидов не из контейнера:
```bash
npm run knex:dev migrate latest
```

```bash
npm run knex:dev seed run
```
Также можно использовать и остальные команды (`migrate make <name>`,`migrate up`, `migrate down` и т.д.)

Для запуска приложения в режиме разработки:
```bash
npm run dev
```
при этом, чтобы при локальном запуске был доступ к БД, то можно запустить postgres либо в контейнере (если у вас есть например docker desktop на windows), либо просто установленый локально postgres, и приложение будет подключаться к БД по localhost.

Финальный Запуск для работы двух контейнеров (приложение и БД) в докере:
```bash
docker compose up -d --build
```


Описание:

1. Делаем заготовки для миграций:
npm run knex:dev migrate make 001_create_table_warehouses
npm run knex:dev migrate make 002_create_table_tariff_requests
npm run knex:dev migrate make 003_create_table_tariffs
npm run knex:dev migrate make 004_tariff_requests_change
npm run knex:dev migrate make 005_create_view_current_tariffs


2. создаём таблицы в БД (три таблицы и одно представление View):
1) таблица warehouses - справочник складов
2) таблица tariff_requests - фиксация каждого сделанного запроса в WB (для истории)
3) таблица tariffs - тарифы складов. Поддерживается логика, в которой при запросах одного дня - происходит обновление имеющихся данных, а в новый день - новые записи. Т.е. если у нас 67 складов, то каждый новый день в эту таблицу будет добавляться по 67 новых записей.
4) Представление current_tariffs - хранит всегда самые последние значения. Также эта информация удобна для заполнения Excel. Т.е. каждый раз когда мы хотим записать данные в Excel, мы делаем запрос к этому представлению, конвертируем данные из БД в двумерный массив и отправляем в гугл таблицы.

логика перезаписи в случае когда запрос повторяется в течении одного дня:
По сути, при каждом новом запросе к WB, мы производим в БД полную запись всех тарифов, как бы с нуля. Вместе с тем удаляем записи которые ссылаются на устаревшие request id в течении этого же дня.

Для запуска программы вам потребуется получить свой JSON-файл сервисного аккаунта на облачной платформе google и положить его в проект и прописать его в:
- прописать переменную окружения в файле env - в моем случае это GOOGLE_APPLICATION_CREDENTIALS="src/google-service/peerless-tiger-470113-s4-5bfd19996102.json"
- прописать переменную окружения в файле compose.yml
- прописать команду в dockerfile, которая копирует данный файл в контейнер: COPY --from=build /app/src/google-service/peerless-tiger-470113-s4-5bfd19996102.json ./dist/google-service/
- добавить этот путь в .gitignore чтобы в репозиторий не попали чувствительные данные

из того, что можно было сделать, но не успел:
1) в гугл таблицах немножко не успел, чтобы можно было писать в разные таблицы. Т.е. не успел разобраться, как создавать новые таблицы автоматизированно. Таким образом, я создал одну таблицу вручную, дал доступ для редактирования и все данные перезаписываются в неё.
2) в гугл таблицах записывать дату вболее читаемом формате вместо Mon Aug 25 2025 22:46:27 GMT+0300 (Москва, стандартное время)
3) в гугл таблицах также можно сделать русскоязычные заголовки
4) много кода на js, т.к. он быстрее работает. Когда делаешь маленькие изменения и запускаешь код, каждый раз надо ждать 2-5 сек для транспиляции ts в js. Поэтому, если нужно больше ts, то будем писать на нём. В целом убеждён, что если писать код более объектно, тогда и ts не так уж и сильно нужен. Т.е., конечно он приносит пользу, но возможно эта польза немного преувеличена. К тому же вначале js-файла можно писать //@ts-check и IDE будет проверять типы.
5) можно было ещё поднять express с тестовыми ендпоинтами.
6) из таблицы warehouses можно было отдельно выделить таблицу-справочник geo_names
7) развертывание devops возможно сделано с ошибками, т.к. опыта devops немного. У меня больше упор на сложную доменную логику, использование объектов и их композиции.